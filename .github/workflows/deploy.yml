name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  # --------------------
  # 1) TEST
  # --------------------
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend

    env:
      ENV: ${{ secrets.ENV }}
      DEBUG_MODE: ${{ secrets.DEBUG_MODE }}
      TEST_DATABASE_USER: ${{ secrets.TEST_DATABASE_USER }}
      TEST_DATABASE_PASSWORD: ${{ secrets.TEST_DATABASE_PASSWORD }}
      TEST_DATABASE_NAME: ${{ secrets.TEST_DATABASE_NAME }}
      TEST_DATABASE_HOST: ${{ secrets.TEST_DATABASE_HOST }}
      TEST_DATABASE_PORT: ${{ secrets.TEST_DATABASE_PORT }}
      PHARMACY_API_HOST: ${{ secrets.PHARMACY_API_HOST }}
      PHARMACY_API_PORT: ${{ secrets.PHARMACY_API_PORT }}
      SESSION_NAME: ${{ secrets.SESSION_NAME }}
      SESSION_DURATION: ${{ secrets.SESSION_DURATION }}
      DO_HOST: ${{ secrets.DO_HOST }}
      DO_USER: ${{ secrets.DO_USER }}
      DO_SSH_KEY: ${{ secrets.DO_SSH_KEY }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: ${{ secrets.TEST_DATABASE_USER }}
          POSTGRES_PASSWORD: ${{ secrets.TEST_DATABASE_PASSWORD }}
          POSTGRES_DB: ${{ secrets.TEST_DATABASE_NAME }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
      
      - name: Debug secrets
        run: |
          echo "DB user=${{ secrets.TEST_DATABASE_USER }}"
          echo "DB name=${{ secrets.TEST_DATABASE_NAME }}"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Wait for Postgres to be ready (timeout 30s)
        run: |
          timeout=30
          elapsed=0
          until pg_isready -h postgres -p 5432; do
            echo "Waiting for Postgres..."
            sleep 2
            elapsed=$((elapsed + 2))
            echo "Waiting for Postgres..."
            if [ $elapsed -ge $timeout ]; then
              echo "::error::Postgres did not start in time"
              echo "=== Postgres logs ==="
              docker logs ${{ job.services.postgres.id }} || true
              exit 1
            fi
          done

      - name: Run Tests
        run: |
          pytest -v --disable-warnings

  # --------------------
  # 2) BUILD (runs after test)
  # --------------------
  build:
    name: Build and Link Services (Docker Compose)
    runs-on: ubuntu-latest
    needs: test   # only run after tests pass

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and Start Services
        run: |
          # Build images defined in docker-compose.yml
          docker-compose build
          
          # Start containers in detached mode
          docker-compose up -d
          
          # List running containers for verification
          docker ps

      - name: Stop and Remove Containers (Cleanup)
        run: |
          docker-compose down


  # --------------------
  # 3) DEPLOY (runs after build)
  # --------------------
  deploy:
    name: Deploy to DigitalOcean Droplet
    runs-on: ubuntu-latest
    needs: build   # only run if build job succeeds

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.8.1
        with:
          ssh-private-key: ${{ secrets.DO_SSH_KEY }}

      - name: Deploy with SSH
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.DO_USER }}@${{ secrets.DO_HOST }} << 'EOF'
            cd ~/pharmacy_app
            git pull origin main         # update latest code
            docker-compose build         # build backend/frontend images on droplet
            docker-compose up -d         # start containers in production
          EOF
